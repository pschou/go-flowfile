package flowfile // import "github.com/pschou/go-flowfile"

import (
	"io"
)

// A wrapper around an io.Reader which parses out the flow files.
type Scanner struct {
	r         io.Reader
	err       error
	last, one *File
	every     func(*File)
}

// Create a new FlowFile reader, wrapping io.Reader for reading consecutive
// FlowFiles from a stream.
func NewScanner(in io.Reader) *Scanner {
	return &Scanner{
		r: in,
	}
}

// Close out any file remaining (if any)
func (r *Scanner) Close() (err error) {
	if r.last != nil {
		// Make sure last reader has been closed out
		if err = r.last.Close(); err != nil && err != io.EOF {
			r.err = err
		}
		r.last = nil
	}
	r.r = nil
	return r.Err()
}

// If a scan was not able to proceed due to an error, get the last error seen.
func (r *Scanner) Err() error {
	if r.err == io.EOF {
		return nil
	}
	return r.err
}

// Scan advances the Scanner to the next token, which will then be available
// through the File method. It returns false when the scan stops, either by
// reaching the end of the input or an error. After Scan returns false, the Err
// method will return any error that occurred during scanning, except that if
// it was io.EOF, Err will return nil.
func (r *Scanner) Scan() bool {
	if r.err == io.EOF {
		return false
	}

	// If this is a one-off reader, send the one and close out
	if r.r == nil {
		if r.one != nil {
			r.last, r.one = r.one, nil
			if r.every != nil {
				r.every(r.last)
			}
			return true
		}
		if r.last != nil {
			r.last.Close()
		}
		return false
	}

	// Before we read the next from a stream, the previous must be closed
	if r.last != nil {
		var last *File
		last, r.last = r.last, nil
		// Make sure last reader has been closed out
		if r.err = last.Close(); r.err == io.EOF {
			return false
		}
	}

	// If there were any errors seen then return them
	if r.err != nil {
		return false
	}

	// Read a File from the reader
	r.last, r.err = parseOne(r.r)
	if r.last != nil && r.every != nil {
		r.every(r.last)
	}
	return r.last != nil
}

// File returns the most recent token generated by a call to Scan.
func (r *Scanner) File() (f *File) {
	if r.last != nil && r.last.cksumStatus == cksumPreinit {
		r.last.cksumInit()
	}
	f = r.last
	return
}
