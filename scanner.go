package flowfile // import "github.com/pschou/go-flowfile"

import (
	"io"
)

// A wrapper around an io.Reader which parses out the flow files.
type Scanner struct {
	r     io.Reader
	err   error
	last  *File
	ch    chan *File
	every func(*File)
}

// Create a new FlowFile reader, wrapping io.Reader for reading consecutive
// FlowFiles from a stream.
func NewScanner(in io.Reader) *Scanner {
	return &Scanner{
		r: in,
	}
}

// Create a new FlowFile reader, using a (chan *File) for reading consecutive
// FlowFiles from a channel.
func NewScannerChan(ch chan *File) *Scanner {
	return &Scanner{
		ch: ch,
	}
}

// Create a new FlowFile reader, for reading from a slice of FlowfFles.
func NewScannerSlice(ff ...*File) *Scanner {
	ch := make(chan *File, len(ff))
	for _, f := range ff {
		ch <- f
	}
	close(ch)
	return &Scanner{
		ch: ch,
	}
}

// Close out any file remaining (if any)
func (r *Scanner) Close() (err error) {
	if r.last != nil {
		// Make sure last reader has been closed out
		if err = r.last.Close(); err != nil && err != io.EOF {
			r.err = err
		}
		r.last = nil
	}
	r.r = nil
	return r.Err()
}

// If a scan was not able to proceed due to an error, get the last error seen.
func (r *Scanner) Err() error {
	if r.err == io.EOF {
		return nil
	}
	return r.err
}

// Scan advances the Scanner to the next token, which will then be available
// through the File method. It returns false when the scan stops, either by
// reaching the end of the input or an error. After Scan returns false, the Err
// method will return any error that occurred during scanning, except that if
// it was io.EOF, Err will return nil.
func (r *Scanner) Scan() (more bool) {
	if r.err == io.EOF {
		return
	}

	// If this is a one-off reader, send the one and close out
	if r.r == nil {
		if r.ch != nil {
			if r.last != nil {
				r.last.Close()
			}

			r.last, more = <-r.ch
			if more && r.every != nil {
				r.every(r.last)
			}
		}
		return
	}

	// Before we read the next from a stream, the previous must be closed
	if r.last != nil {
		var last *File
		last, r.last = r.last, nil
		// Make sure last reader has been closed out
		if r.err = last.Close(); r.err == io.EOF {
			return
		}
	}

	// If there were any errors seen then return them
	if r.err != nil {
		return
	}

	// Read a File from the reader
	r.last, r.err = parseOne(r.r)
	if r.last != nil && r.every != nil {
		r.every(r.last)
	}
	return r.last != nil
}

// File returns the most recent token generated by a call to Scan.
func (r *Scanner) File() (f *File) {
	if r.last != nil && r.last.cksumStatus == cksumPreinit {
		r.last.ChecksumInit()
	}
	f = r.last
	return
}
